---
title: "Les chaines de caract√®res üß∂"
subtitle: "Utiliser les expressions r√©guli√®res"
author: "Pascal Burkhard"
institute: "LDDR 2020-2021"
knit: pagedown::chrome_print
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts, personal.css]
    lib_dir: libs
    self_contained: true
    nature:
      ratio: 16:9
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
library(xaringanthemer)
library(flair)
options(htmltools.dir.version = FALSE)
style_extra_css(
  css = list(
    ".remark-slide-content" = list("padding-left" = "80px", "padding-right" = "80px"),
    ".remark-code" = list("background" = "#dedede !important", "white-space" = "pre-wrap !important"),
    ".remark-code-line" = list("color" = "#00496f"),
    ".remark-inline-code" = list("background" = "#dedede !important"),
    ".pull-left" = list("float" = "left", "width" = "47%"),
    ".pull-right" = list("float" = "right", "width" = "47%"),
    ".pull-left-large" = list("float" = "left", "width" = "63%"),
    ".pull-right-large" = list("float" = "right", "width" = "63%"),
    ".pull-left-small" = list("float" = "left", "width" = "30%"),
    ".pull-right-small" = list("float" = "right", "width" = "30%"),
    ".bordered" = list("display" = "inline-block", "border" = "1px solid black"),
    ".flair-pink code" = list("background-color" = "#ad8cae !important"),
    ".flair-blue code" = list("background-color" = "#4f93b8 !important"),
    ".flair-green code" = list("background-color" = "#2e9093 !important"),
    ".flair-orange code" = list("background-color" = "#ee950b !important"),
    ".flair-red code" = list("background-color" = "#dd4123 !important")
  ),
  outfile = "personal.css",
  append = FALSE,
  heading = "Extra CSS"
)
```

```{r, load_refs, include=FALSE, cache=FALSE}
library(RefManageR)
BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = "alphabetic",
           style = "markdown",
           hyperlink = FALSE,
           dashed = FALSE)
bibliography <- ReadBib("./bibliography.bib", check = FALSE)
NoCite(
  bibliography,
  c("downey_think_2012", "mueller_beginning_2018", "friedl_mastering_2006", "fitzgerald_introducing_2012", "stubblebine_regular_2007", "courtois_les_nodate")
)
```

# Exercice 1

## Consignes

- ouvrez le fichier `adresses_facile.csv` dans Excel
- observez les num√©ros de t√©l√©phone dans la colonne `Tel`
- modifiez les num√©ros pour qu'ils correspondent au format `0123456789`

## Questions

- peut-on modifier tous les num√©ros pour obtenir un format `012 345 67 89` pour les num√©ros ?
- et un format `+41 12 345 67 89`

---

# Exercice 2

## Consignes

- importez les donn√©es du fichier `adresses_facile.csv` dans une liste de dictionnaires (en utilisant le module `csv` comme indiqu√© ci-dessous)

```{python, eval=F}
import csv

adresses_dict = csv.DictReader(open("chemin/vers/adresses_facile.csv"))
adresses_dict = list(adresses_dict)
```

- en utilisant vos connaissances actuelles, modifiez le format des num√©ros pour correspondre √† `+41 12 345 67 89`

- r√©p√©tez l'exercice avec le fichier `adresses_intermediaire.csv`

--

- observez le fichier `adresses_expert.csv` r√©fl√©chissez √† une proc√©dure pour modifier les num√©ros de t√©l√©phone  
comment pourrait-on proc√©der ?

---

# Les expressions r√©guli√®res √† la rescousse ü¶∏

```{r, out.width="50%", fig.align='left', echo=FALSE}
knitr::include_graphics("img/regular_expressions.png")
```

.pull-right[.footnote[
*Source : https://xkcd.com/208/*
]]

---

# Les expressions r√©guli√®res‚Ä¶

## ‚Ä¶ c'est quoi ?

Les **expressions r√©guli√®res** (*regular expression* ou ***regex*** en anglais) ou parfois aussi *expressions rationnelles* permettent de d√©crire un ensemble de caract√®res au moyen d'un **motif** (*pattern* en anglais). Ce motif peut √™tre plus ou moins complexe.

Les expressions r√©guli√®res peuvent √™tre consid√©r√©es comme un langage de programmation en soit. Elles permettent d'effectuer des t√¢ches sp√©cialis√©es de **recherche** et de **remplacement**.

Les expressions r√©guli√®res sont pr√©sentes dans un tr√®s grand nombre de langages de programmation, int√©gr√©es directement (comme dans *Perl* par exemple) ou √† travers une extension (comme avec le module *re* dans *Python* üêç).

Les expressions r√©guli√®res sont √©galement int√©gr√©es dans un grand nombre d'√©diteurs de texte et d'environnements de d√©veloppement (IDE).

---

# Les expressions r√©guli√®res

## Un peu d'histoire

.pull-left-large[
La th√©orie qui donne naissance aux expressions r√©guli√®res √©merge des travaux de Warren McCulloch et Walter Pitts qui d√©crivent le fonctionnement des neurones dans le syst√®me neveux dans les ann√©es 1940. En ce basant sur ces travaux, le logicien **Stephen Cole Kleene** d√©crit les mod√®les imagin√©s sous forme d'ensembles r√©guliers et d'automates. Il est consid√©r√© comme le p√®re des ***expressions r√©guli√®res***.

Les expressions r√©guli√®res font leur apparition dans le monde de l'informatique dans les ann√©es 1980 lorsqu‚Äôelles sont int√©gr√©es dans le programme *ed* ‚Äì un √©diteur de texte du syst√®me d'exploitation UNIX. Elles seront ensuite int√©gr√©es dans d'autre petits logiciels ou utilitaires (comme *vi*, *awk*, *grep*, *Emacs*) et dans divers langages de programmation (comme *Perl*, *Java* ou encore *Python* üêç).
]

.pull-right-small[
```{r, out.width="80%", fig.align='left', echo=FALSE}
knitr::include_graphics("img/stephen_cole_kleene.jpg")
```

Stephen Cole Kleene  
*Source: [Wikimedia](https://commons.wikimedia.org/wiki/File:Kleene.jpg)*
]

---

# Les expressions r√©guli√®res

## L'impl√©mentation

Divers langages de programmation impl√©mentent les expressions r√©guli√®res. Ces impl√©mentations varient *malheureusement* d'un langage √† un autre. M√™me s'il existe des standards (comme le standard *POSIX* du monde *UNIX*, ou le standard *PCRE* impl√©ment√© dans le langage *Perl*), de petites divergences subsistent.

Les expressions r√©guli√®res dans *Python* üêç suivent le standard *POSIX* avec quelques petites diff√©rences. Dans le cadre de cette introduction, ces diff√©rences n'ont aucun impact. Il est cependant prudent de tester son expression r√©guli√®re dans un moteur (voir *Ressources utiles* dans l'aide-m√©moire) qui correspond au standard utilis√© !

---

# Les expressions r√©guli√®res

## Comment √ßa marche ?

Une expression r√©guli√®re est un **motif** d√©finissant un ensemble de chaines de caract√®res. Le motif d'une expression r√©guli√®re est compos√© de diff√©rents **symboles** :

- des **caract√®res litt√©raux**  
des symboles qui expriment *litt√©ralement* le caract√®re (le symbole correspond √† lui-m√™me), par exemple le symbole `a` correspond √† la lettre *a*

- des **m√©tacaract√®res**  
des symboles qui ne correspondent pas directement √† eux-m√™mes ‚Äì ces symboles ont une signification particuli√®re d√©crite par la suite  
dans les expressions r√©guli√®res de *Python* üêç ils sont au nombre de 14 : `. ^ $ * + ? { } [ ] \ | ( )`

---

# Les caract√®res litt√©raux

La plupart des symboles d'une expression r√©guli√®re sont des *caract√®res litt√©raux* : ils se d√©crivent eux-m√™mes.

Le motif .flair-pink[`in`] sera par exemple d√©tect√© de la mani√®re suivante dans la chaine de caract√®res ci-dessous :

```{r regex_example_litteral, eval=FALSE, echo=FALSE}
L'informatique n'est qu'un outil, comme un pinceau ou un crayon.
```

```{r, echo=FALSE}
decorate("regex_example_litteral", eval=FALSE) |>
  flair_rx("in", background = "#ad8cae")
```

---

# Les m√©tacaract√®res

Les m√©tacaract√®res utilis√©s dans les expressions r√©guli√®res sont utilis√©s pour les applications suivantes :

- des ancrages  
d√©finir un point pr√©cis dans une chaine de caract√®res, tel que le d√©but de la chaine ou la limite d'un mot par exemple

- des classes de caract√®res et des groupes  
d√©finir un groupe de caract√®res √† faire correspondre

- des quantifieurs  
d√©finir le nombre de fois qu'une partie du motif de l'expression r√©guli√®re est r√©p√©t√©

Les m√©tacaract√®res permettent √©galement d'autres fonctions avanc√©es, qui d√©passent le cadre de ce cours.

---

# Les m√©tacaract√®res

## Les ancrages

Les ancrages permettent de fixer un motif √† un point pr√©cis de la chaine de caract√®res. Ces m√©tacaract√®res permettent de se fixer sur des √©l√©ments *invisibles* d'une chaine de caract√®res. Les ancrages principaux sont :

- `^` : correspond au d√©but d'une ligne (avec des chaines de caract√®res multilignes)
- `$` : correspond √† la fin d'une ligne (avec des chaines de caract√®res multilignes)
- `\A` : correspond au d√©but d'une chaine de caract√®res
- `\Z` : correspond √† la fin d'une chaine de caract√®res
- `\b` : correspond √† la limite d'un mot (d√©but ou fin)
- `\B` : correspond √† l'oppos√© de `\b` (toute position sauf le d√©but ou la fin d'un mot)

---

# Les m√©tacaract√®res

## Les ancrages ‚Äì quelques exemples

Observez comment l'ancre `\A` restreint le motif .flair-green[`\Aun programme`] :

```{r regex_example_anchors_1, eval=FALSE, echo=FALSE}
un programme sans bug est un programme qui n'a pas √©t√© suffisament test√©
```

```{r, echo=FALSE}
decorate("regex_example_anchors_1", eval=FALSE) |> 
  flair_rx("\\Aun programme", background = "#2e9093")
```

Observez la diff√©rence entre les motifs .flair-blue[`\Bqu`] et .flair-pink[`\bqu`] :

```{r regex_example_anchors_2, eval=FALSE, echo=FALSE}
Comme la Hongrie, le monde informatique a une langue qui lui est propre. Mais il y a une diff√©rence. Si vous restez assez longtemps avec des Hongrois, vous finirez bien par comprendre de quoi ils parlent.
```

```{r, echo=FALSE}
decorate("regex_example_anchors_2", eval=FALSE) |> 
  flair_rx("\\bqu", background = "#ad8cae") |> 
  flair_rx("\\Bqu", background = "#4f93b8")
```

---

# Les m√©tacaract√®res

## Les classes de caract√®res

Les classes de caract√®res permettent de d√©finir une collection de caract√®res. Les crochets permettent de d√©finir des classes de caract√®res. Par exemple le motif `[abc]` peut correspondre √† la lettre *a* comme *b* ou *c*. Il est √©galement possible d'inverser une classe de caract√®re en utilisant le symbole `^` au d√©but de l'ensemble. Par exemple `[^abc]` va correspondre √† tous les symboles sauf *a*, *b* et *c*. Certaines classes de caract√®res sont d√©finies avec des *raccoucis*. Quelques classes de caract√®res utilis√©es fr√©quemment :  

- `.` : correspond √† n'importe quel symbole
- `[0-9]` ou `\d` : correspondent √† tous les chiffres
- `[^0-9]` ou `\D` : correspondent √† tout sauf les chiffres
- `[a-z]` : correspond aux lettres minuscules *a* √† *z*
- `\s` : correspond aux espaces
- `\S` : correspond √† tout sauf aux espaces
- `\w` : correspond aux lettres, chiffres et au symbole `_` (√©quivalent √† `[A-Za-z0-9_]`)
- `\W` : correspond √† tout sauf aux lettres, chiffres et au symbole `_` (√©quivalent √† `[^A-Za-z0-9_]`)

---

# Les m√©tacaract√®res

## Les classes de caract√®res

Le standard *POSIX* d√©finit par ailleurs des classes avec un format `[:mot:]`. Quelques exemples (non exhaustif) :

- `[:upper:]` : Lettres majuscules
- `[:lower:]` : Lettres minuscules
- `[:alpha:]` : Lettres majuscules et minuscules
- `[:alnum:]` : Lettres et chiffres
- `[:digit:]` : Chiffres (correspond √† `\d` ou `[0-9]`)
- `[:punct:]` : Ponctuation

Les classes `[:upper:]`, `[:lower:]`, `[:alpha:]` et `[:alnum:]` ont l'√©norme avantage (en fran√ßais surtout) d'inclure les caract√®res accentu√©s (ce que `[A-Z]` ou `[a-z]` ne fait pas) !

---

# Les m√©tacaract√®res

## Les classes de caract√®res ‚Äì quelques exemples

Observez les occurrences des motifs .flair-blue[`\s`], .flair-pink[`\d`] et .flair-green[`[pl]`] dans la chaine de caract√®res ci-dessous :

```{r regex_example_classes_1, eval=FALSE, echo=FALSE}
2 n'est pas √©gal √† 3, m√™me pour de grandes valeurs de 2 ou de petites valeurs de 3.
```

```{r, echo=FALSE}
decorate("regex_example_classes_1", eval=FALSE) |> 
  flair_rx("\\s", background = "#4f93b8") |> 
  flair_rx("\\d", background = "#ad8cae") |> 
  flair_rx("[pl]", background = "#2e9093")
```

Et le motif .flair-blue[`[A-Z]`] dans la phrase ci-dessous :

```{r regex_example_classes_2, eval=FALSE, echo=FALSE}
Si vous mettez 30 novices devant un ordinateur √©quip√© de Windows, vous aurez 30 mani√®res diff√©rentes de planter Windows.
```

```{r, echo=FALSE}
decorate("regex_example_classes_2", eval=FALSE) |> 
  flair_rx("[A-Z]", background = "#4f93b8")
```

Notez la diff√©rence entre le motif .flair-blue[`[A-Za-z]`] et le motif .flair-pink[`[:alpha:]`].

```{r regex_example_classes_3, eval=FALSE, echo=FALSE}
Tout ordinateur est obsol√®te au plus tard √† son d√©ballage.
```

```{r regex_example_classes_4, eval=FALSE, echo=FALSE}
Tout ordinateur est obsol√®te au plus tard √† son d√©ballage.
```

```{r, echo=FALSE}
decorate("regex_example_classes_3", eval=FALSE) |> 
  flair_rx("[A-Za-z]", background = "#4f93b8")

decorate("regex_example_classes_4", eval=FALSE) |> 
  flair_rx("[:alpha:]", background = "#ad8cae")
```


---

# Les m√©tacaract√®res

## Les groupes

Les m√©tacaract√®res `(` et `)` permettent de d√©finir un groupe dans un motif. Il existe deux types de groupes, les groupes *capturant* et *non-capturant*. Cette distinction devient particuli√®rement pertinente lorsqu'on proc√®de √† des remplacements en utilisant des expressions r√©guli√®res.

- `(bug)` : groupe capturant avec le motif `bug`
- `(?:bug)` : groupe non capturant avec le motif `bug`

Les groupes sont particuli√®rement pertinents lorsqu'on utilise le m√©tacaract√®re `|` (op√©rateur logique *OU*). Quelques exemples :

- `(Tom|Fred)` : groupe capturant avec le motif `Tom` ou le motif `Fred`
- `ser(ons|ez|ont)` : motif correspondant aux formes pluriels du futur simple du verbe √™tre

---

# Les m√©tacaract√®res

## Les quantifieurs

Les quantifieurs permettent d'exprimer un nombre de fois qu'une partie du motif (un caract√®re litt√©ral, un groupe ou une classe de caract√®res) peut √™tre r√©p√©t√©e :

- `?` : 0 ou 1 fois
- `*` : 0 fois ou plus
- `+` : 1 fois ou plus
- `{2}` : 2 fois (exactement)
- `{6}` : 6 fois (exactement)
- `{3,5}` : 3, 4 ou 5 fois
- `{4,}` : 4 fois ou plus

Les quantifieurs sont *gourmands* par d√©faut. Cela signifie qu'ils engloberont toujours le maximum de symboles possibles. En rajoutant un `?` aux quantifieurs ci-dessus (par exemple `??`, `*?`, `+?`, `{2,}?` ou `{3,6}?`), ceux-ci deviendront *minimalistes* et engloberont le moins de symboles possibles.

Les quanfitieurs sont g√©n√©ralement combin√©s avec une classe de caract√®res ou un groupe, mais ils peuvent aussi s'appliquer √† un caract√®re litt√©ral.

---

# Les m√©tacaract√®res

## Les quantifieurs ‚Äì quelques exemples

Observez le r√©sultat du motif .flair-blue[`(tr√®s\s)+`] ci-dessous :

```{r regex_example_quantifiers_1, echo=FALSE, eval=FALSE}
Les composantes d'un microprocesseur sont tr√®s tr√®s tr√®s tr√®s petites!
```

```{r, echo=FALSE}
decorate("regex_example_quantifiers_1", eval=FALSE) |> 
  flair_rx("(tr√®s\\s)+", background = "#4f93b8", class = "bordered")
```

et comparez avec le r√©sultat du motif .flair-pink[`(tr√®s\s)+?`] ci-apr√®s :

```{r regex_example_quantifiers_2, echo=FALSE, eval=FALSE}
Les composants d'un microprocesseur sont tr√®s tr√®s tr√®s tr√®s petits!
```

```{r, echo=FALSE}
decorate("regex_example_quantifiers_2", eval=FALSE) |> 
  flair_rx("(tr√®s\\s)+?", background = "#ad8cae", class = "bordered")
```

--

notez la diff√©rence entre un quantifieur *gourmand* et *minimaliste* !

---

# Les m√©tacaract√®res

## Les quantifieurs ‚Äì quelques exemples

Les quantifieurs peuvent √©galement s'av√©rer tr√®s utiles en combinaison avec des classes de caract√®re. Le motif .flair-pink[`\A[^,]*`] identifie la premi√®re partie de la phrase ci-dessous jusqu'√† rencontrer une virgule :

```{r regex_example_quantifiers_3, echo=FALSE, eval=FALSE}
Gr√¢ce √† l'ordinateur, on peut faire plus rapidement des choses qu'on n'aurait pas eu besoin de faire sans ordinateur.
```

```{r, echo=FALSE}
decorate("regex_example_quantifiers_3", eval=FALSE) |> 
  flair_rx("\\A[^,]*", background = "#ad8cae")
```

On peut √©galement appliquer les quantifieurs √† des raccourcis (comme `\S` dans l'exemple ci-apr√®s). Le motif .flair-blue[`\b\S{5,}\b`] correspond aux mots de 5 caract√®res et plus :

```{r regex_example_quantifiers_4, echo=FALSE, eval=FALSE}
Rappelez-vous que ce n'est pas un hasard si l'informatique et la th√©orie du chaos se sont d√©velopp√©es simultan√©ment.
```

```{r, echo=FALSE}
decorate("regex_example_quantifiers_4", eval=FALSE) |> 
  flair_rx("\\b\\S{5,}\\b", background = "#4f93b8")
```

---

# Les m√©tacaract√®res

## *√âchapper* un m√©tacaract√®re

Le m√©tacaract√®re `\` (*barre oblique inverse* ou *backslash* en anglais) permet d'*√©chapper* les m√©tacaract√®res.

Par exemple, lorsqu'on souhaite utiliser le symbole `.` dans une expression r√©guli√®re, il faut l'*√©chapper*. On obtiendra le motif suivant .flair-pink[`\\.`] :

```{r regex_example_escape, echo=FALSE, eval=FALSE}
Un programme informatique fait ce que vous lui avez dit de faire, pas ce que vous voulez qu'il fasse.
```

```{r, echo=FALSE}
decorate("regex_example_escape", eval=FALSE) |> 
  flair_rx("\\.", background = "#ad8cae")
```

On notera √©galement que dans une classe de caract√®res (entre crochets `[]`), seul le crochet fermant `]` et le circonflexe `^` (lorsqu'il est au d√©but) doivent √™tre √©chapp√©s.

---

# Les expressions r√©guli√®res dans *Python* üêç

Lorsqu'on utilise des expressions r√©guli√®res dans *Python* üêç, on se trouve rapidement confront√© au conflit du m√©tacaract√®re `\` utilis√© dans les expressions r√©guli√®res pour √©chapper les m√©tacaract√®res, mais √©galement dans les chaines de caract√®res de *Python* üêç. Par exemple lorsqu'on d√©limite une chaine de caract√®res avec des apostrophes, la *barre oblique inverse* permet d'√©chapper l'apostrophe : `'aujourd\'hui'`.

On se retrouverait donc √† devoir √©chapper doublement les `\` pour que ceux-ci fonctionnent correctement. Le motif `\b\S{5,}\b` pr√©sent√© pr√©c√©demment, deviendrait `\\b\\S{5,}\\b` : cela devient vite un cauchemard !

Fort heureusement *Python* üêç nous offre une solution simple √† ce probl√®me : les *chaines de caract√®res brutes* (*raw strings* en anglais). Cette structure permet d'√©viter l'√©chappement par Python. Une *chaine de caract√®res brute* est cr√©√©e en pr√©fixant la chaine de caract√®res d'une lettre *r* (ou *R*) :

```{r, eval=FALSE}
r'chaine brute\ dans laquelle la barre oblique est maintenue telle quelle'
r"deuxi√®me chaine brute\ avec la m√™me barre oblique"
```

Seule limitation de ces chaines brutes : les apostrophes ou guillemets (selon ce qui est utilis√©) peuvent √™tre √©chapp√©s. On ne pourra donc pas avoir la chaine brute suivante : `r'\'` !

---

# Les expressions r√©guli√®res dans *Python* üêç

Pour travailler avec des expressions r√©guli√®res dans Python il faut importer le module *re* :

```{python, results='hide'}
import re
```

Le module *re* propose plusieurs m√©thodes pour travailler avec des expressions r√©guli√®res dans *Python* üêç. Nous allons nous concentrer sur trois m√©thodes :

- re.**findall**(*pattern, string, flags=0*)
- re.**split**(*pattern, string, maxsplit=0, flags=0*)
- re.**sub**(*pattern, repl, string, count=0, flags=0*)

La m√©thode `findall()` permet de trouver toutes les occurrences du motif (*pattern*) dans la chaine (*string*). Cette m√©thode retourne une liste des occurrences trouv√©es.

La m√©thode `split()` permet de diviser la chaine (*string*) en coupant l√† o√π elle trouve le motif (*pattern*). Le param√®tre *maxsplit* permet de sp√©cifier un nombre de morceaux maximal. Cette m√©thode retourne √©galement une liste.

La m√©thode `sub()` permet de remplacer une dans une chaine (*string*) les motifs (*pattern*) par la chaine sp√©cifi√©e par le param√®tre *repl*.

---

# Les expressions r√©guli√®res dans *Python* üêç

## re.**findall**(*pattern, string, flags=0*)

Quelques exemples :

```{python}
re.findall(r"\d+", "Un ordinateur fait autant d'erreur en 2 secondes que 20 humains en 20 ans.")
```

--

```{python, tidy.opts=list(width.cutoff=50)}
re.findall(r"\b\S{5,}\b", "Rappelez-vous que ce n'est pas un hasard si l'informatique et la th√©orie du chaos se sont d√©velopp√©es simultan√©ment.")
```

---

# Les expressions r√©guli√®res dans *Python* üêç

## re.**split**(*pattern, string, maxsplit=0, flags=0*)

Quelques exemples :

```{python}
re.split(r"/", "un/deux/trois/quatre/cinq/six/sept")
```

--

```{python}
re.split(r"\W", "C'est quand votre ordinateur est √©teint qu'il fonctionne le mieux.")
```

---

# Les expressions r√©guli√®res dans *Python* üêç

## re.**sub**(*pattern, repl, string, count=0, flags=0*)

```{python}
re.sub(r"√†[^,]*", "aux expressions r√©guli√®res", "Quand on se met √† l'informatique, il vaut mieux avoir BEAUCOUP d‚Äôamis.")
```

--

Dans le cadre des remplacements, les groupes *capturant* prennent tout leur sens. On peut en effet utiliser des *r√©f√©rences* √† ces groupes dans l'argument *repl*. Ces r√©f√©rences prennent la forme `\1` pour le premier groupe, `\2` pour le deuxi√®me groupe et ainsi de suite. Notez l'utilisation d'une chaine brute pour l'argument de remplacement :

```{python regex_sub, echo=FALSE, eval=FALSE}
re.sub(r"0(\d{2})\s(\d{3})\s(\d{2})\s(\d{2})", r"+41 \1 \2 \3 \4", "012 345 67 89")
```

```{r, echo=FALSE}
decorate("regex_sub") |> 
  flair_rx(r"[(?<=0\()\\d\{2\}]", background = "#ee950b") |> 
  flair_rx(r"[\\1]", background = "#ee950b") |> 
  flair_rx("12", background = "#ee950b") |> 
  flair_rx(r"[\\d\{3\}]", background = "#dd4123") |> 
  flair_rx(r"[\\2]", background = "#dd4123") |> 
  flair_rx("345", background = "#dd4123") |> 
  flair_rx(r"[(?<=\\s\()\\d\{2\}(?=\)\\s)]", background = "#ad8cae") |>
  flair_rx(r"[\\3]", background = "#ad8cae") |> 
  flair_rx("67", background = "#ad8cae") |>
  flair_rx(r'[\\d\{2\}(?=\)")]', background = "#2e9093") |> 
  flair_rx(r"[\\4]", background = "#2e9093") |> 
  flair_rx("89", background = "#2e9093") 
```

---

# Quelques ressources utiles

## R√©f√©rences

- Guides et r√©f√©rences (en anglais) : https://www.regular-expressions.info

- Guides et r√©f√©rences (ax√© sur le langage PHP, en fran√ßais) : http://www.expreg.com

- Exemples d'expressions fr√©quentes : https://projects.lukehaas.me/regexhub/

- Documentation *regex* de *Python* üêç (en fran√ßais) : https://docs.python.org/fr/3/howto/regex.html

## Moteurs d'expressions r√©guli√®res

- https://regexr.com

- https://regex101.com

- https://debuggex.com

---

# Exercice 3

## Consignes

- revisitez le fichier `adresses_facile.csv`
- en utilisant le mod√®le `exercice3_exemple.py`, modifiez l'expression r√©guli√®re (l'expression actuelle `(.*)` ne change rien aux num√©ros de t√©l√©phone) pour obtenir un format `+41 12 345 67 89`.
- lorsque vous y √™tes parvenu avec le fichier `adresses_facile.csv` essayez `adresses_intermediaire.csv` puis `adresses_expert.csv`

## Conseil

Faites usage d'un des moteurs d'expressions r√©guli√®res √©voqu√©s dans l'aide-m√©moire !

---

# R√©f√©rences

```{r refs, echo=FALSE, results="asis"}
PrintBibliography(bibliography)
```
